---
title: "goè¨€èªã¨c++æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª(STL)"
emoji: "ğŸƒ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "golang", "atcoder"]
published: false
---

# c++STLâ†’golang
## ã€€å‹•æ©Ÿ
atcoderã«ãŠã„ã¦ï¼Œå•é¡Œã‚’é€Ÿãè§£ãèƒ½åŠ›ã¯å¿…é ˆã§ã™ï¼c++ã«ã¯è±Šå¯Œãªç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ä¾¿åˆ©ãªæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ï¼ã—ã‹ã—ï¼Œgoè¨€èªã§ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«æŒ‘æˆ¦ã—ã‚ˆã†ã¨ã™ã‚‹ã¨è‡ªåˆ†ã§å®Ÿè£…ã—ãªã‘ã‚Œã°ã„ã‘ãªã„éƒ¨åˆ†ãŒå¤šã„ã“ã¨ã«æ°—ã¥ãã¾ã—ãŸï¼c++ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’goè¨€èªã§æ›¸ã„ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ï¼ã‚¹ãƒ‹ãƒšãƒƒãƒˆãªã©ã«ã”åˆ©ç”¨ãã ã•ã„ï¼

## æ‰±ã†STL
|STL|å†…å®¹|
|:--|:--|
|[abs](#abs)|çµ¶å¯¾å€¤|
|[sin/cos/tan](#sin/cos/tan)|ä¸‰è§’é–¢æ•°|
|[min/max](#min/max)|æœ€å¤§å€¤ãƒ»æœ€å°å€¤|
|[swap](#swap)|å€¤ã®äº¤æ›|
|[GCD](#GCD)|æœ€å¤§å…¬ç´„æ•°|
|[rand](#rand)|ä¹±æ•°|
|[clock](#clock)|æ™‚é–“è¨ˆæ¸¬|
|[reverse](#reverse)|é…åˆ—ã®é€†é †|
|[sort](#sort)|ã‚½ãƒ¼ãƒˆ|
|[vector](#vector)|ãƒ™ã‚¯ã‚¿ãƒ¼|
|[stack](#stack)|ã‚¹ã‚¿ãƒƒã‚¯|
|[queue](#queue)|ã‚­ãƒ¥ãƒ¼|
|[priority_queue](#priority_queue)|å„ªå…ˆåº¦ã¤ãã‚­ãƒ¥ãƒ¼|
|[set](#set)|ã‚»ãƒƒãƒˆ(é›†åˆ)|
|[next_permutation](#next_permutation)|é †åˆ—|

## abs
æ¦‚è¦
çµ¶å¯¾å€¤ã‚’è¿”ã™é–¢æ•°

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main

import (
	"fmt"
	"math"
)

func main() {
	// Get absolute value of integer
	fmt.Println("Absolute value of  5 is ", math.Abs(5))
	fmt.Println("Absolute value of -5 is ", math.Abs(-5))

	// Get absolute value of float
	fmt.Println("Absolute value of  5.5 is ", math.Abs(5.5))
	fmt.Println("Absolute value of -5.5 is ", math.Abs(-5.5))
}
~~~

## sin/cos/tan
æ¦‚è¦
ä¸‰è§’é–¢æ•°
|||
|:--|:--|
|math.Cos(x)|doubleã‚’å—ã‘å–ã£ã¦doubleã§è¿”ã™|

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main
import "fmt"
import "math"
func main() {
var n = math.Cos(45 * math.Pi / 180)
fmt.Printf("%f\n", n)
}
~~~


## min/max
æ¦‚è¦
Go 1.21ã‹ã‚‰ã¯min/maxãŒé–¢æ•°åŒ–ã•ã‚ŒãŸãŒï¼ŒAtCoderã§ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå¤ã„ã¾ã¾ã§ä½¿ç”¨ã§ããªã„ãŸã‚ï¼Œã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãŠãï¼

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
1.14ã®min/maxã§ã¯2å€¤ã®æ¯”è¼ƒã—ã‹ã§ããªã„ï¼
~~~go
package main
import "fmt"
import "math"
func main() {
var n = min(2, 3)
fmt.Printf("%f\n", n)   // -> 2
}
~~~
æ„šç›´ã«ãƒ«ãƒ¼ãƒ—ã‚’å›ã™ã®ãŒã‚ˆã„ï¼
~~~go
//æœ€å¤§
a := []int{1, 5, 2, 3}
if len(a) > 0 {
	max := a[0]
	for _, v := range a {
		if max < v {
			max = v
		}
	}
	fmt.Println(max)
} else {
	fmt.Println("a is empty")
}

//æœ€å°
a := []int{1, 5, 2, 3}
if len(a) > 0 {
	min := a[0]
	for _, v := range a {
		if min > v {
			min = v
		}
	}
	fmt.Println(min)
} else {
	fmt.Println("a is empty")
}
~~~

## GCD
æ¦‚è¦
math/bigã‚’ç”¨ã„ã¦è¨˜è¿°ã§ãã‚‹ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main

import (
    "fmt"
    "math/big"
)

func gcd(m, n uint64) uint64 {
    x := new(big.Int)
    y := new(big.Int)
    z := new(big.Int)
    a := new(big.Int).SetUint64(m)
    b := new(big.Int).SetUint64(n)
    return z.GCD(x, y, a, b).Uint64()
}

func main() {
    fmt.Println(gcd(20, 32)) // 4
}
~~~

## rand
æ¦‚è¦

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
~~~

## clock
æ¦‚è¦
time.Now()ã‚’ä½¿ã£ã¦ç¾åœ¨ã®æ™‚é–“ã‚’è¨ˆæ¸¬ã™ã‚‹ï¼time.Now()ã‚’äºŒåº¦ä½¿ç”¨ã—ã¦å®Ÿè¡Œæ™‚é–“ã‚’è¨ˆæ¸¬ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ãŒï¼Œtime.Since()ã‚’ä½¿ã£ã¦ã‚‚ã‚ˆã„ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main

import (
	"log"
	"time"
)

func main() {
	now := time.Now()

	for i := 0; i < 100000; i++ {
		// æ™‚é–“ã‚’è¨ˆæ¸¬ã™ã‚‹ãŸã‚ã®æ„å‘³ã®ãªã„ã‚³ãƒ¼ãƒ‰
	}

	// Seconds
	log.Printf("It took %fs\n", time.Since(now).Seconds())
	// Milliseconds
	log.Printf("It took %dms\n", time.Since(now).Milliseconds())
	// Microseconds
	log.Printf("It took %dus\n", time.Since(now).Microseconds())
}
~~~

## reverse
æ¦‚è¦

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main

import "fmt"

func reverseArray(arr []int, start int, end int) []int {
    for i, j := start, end; i < j; i, j = i+1, j-1 {
        arr[i], arr[j] = arr[j], arr[i]
    }
    return arr
}

func main() {
	a := []int{100, 200, 300, 400, 500}
    fmt.Println(reverseArray(a, 0, len(a)-1))
}
~~~

## sort
æ¦‚è¦

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
~~~

## vector
æ¦‚è¦
ã‚¹ãƒ©ã‚¤ã‚¹ã¯å¯å¤‰é•·é…åˆ—ã¨ã—ã¦ã‚‚å–ã‚Šæ‰±ã†ã“ã¨ãŒã§ã(ã»ã¼C++ã®vectorã¨åŒã˜ã ãŒ)ï¼Œå®šç¾©ã—ãŸã‚µã‚¤ã‚ºã‚’å¢—ã‚„ã™ã“ã¨ãŒã§ãã‚‹ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
~~~

## stack
æ¦‚è¦
sliceã‚’ç”¨ã„ã¦å®Ÿè£…å¯èƒ½
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
~~~

## queue
æ¦‚è¦
sliceã‚’ç”¨ã„ã¦å®Ÿè£…å¯èƒ½
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
~~~

## priority_queue
æ¦‚è¦

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
// This example demonstrates an integer heap built using the heap interface.
package main

import (
	"container/heap"
	"fmt"
)

// An IntHeap is a min-heap of ints.
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x any) {
	// Push and Pop use pointer receivers because they modify the slice's length,
	// not just its contents.
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() any {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func main() {
	ih := &intHeap{}

	heap.Init(ih)       // ä½¿ç”¨ã™ã‚‹éš›ã«ã¯ã¾ãšInitã‚’å‘¼ã¶
	heap.Push(ih, 3)    // heap.PushçµŒç”±ã§å€¤ã‚’æŠ•å…¥
	heap.Push(ih, 1)
	heap.Push(ih, 10)
	heap.Push(ih, 7)

	for ih.Len() > 0 {
		v := heap.Pop(ih)    // heap.PopçµŒç”±ã§å€¤ã‚’å–ã‚Šå‡ºã™
		fmt.Println(v)
	}
}
// 1, 3, 7, 10ã®é †ã§å‡ºåŠ›ã•ã‚Œã‚‹
~~~
æŠ•å…¥é †ã«é–¢ã‚ã‚‰ãšï¼Œå€¤ã®å°ã•ã„ã‚‚ã®ã‹ã‚‰å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¦ã„ã‚‹ï¼å„ªå…ˆåº¦ã‚’æ±ºã‚ã¦ã„ã‚‹ã®ã¯ï¼ŒintHeap.Lessãƒ¡ã‚½ãƒƒãƒ‰ï¼å†…éƒ¨ã®å‡¦ç†ã®ä¸ç­‰å·ã‚’åè»¢ã•ã›ã‚‹ã¨ï¼Œå€¤ãŒå¤§ãã„ã‚‚ã®ã‹ã‚‰å„ªå…ˆã—ã¦å–ã‚Šå‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚‹ï¼mapã§{å„ªå…ˆåº¦, åå‰}ã‚’ä¿ç®¡ã™ã‚‹ã‚‚ã®ã‚‚è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹

## binary search tree
æ¦‚è¦
äºŒåˆ†æ¢ç´¢
ã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—dataã‹ã‚‰ï¼Œdata[i] >= xã‚’æº€ãŸã™ã‚ˆã†ãªæœ€åˆã®xã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
x := 10
i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
if i < len(data) && data[i] == x {
	// x is present at data[i]
} else {
	// x is not present in data, but i is the index where it would be inserted
}
~~~

## set
æ¦‚è¦
Goã«é›†åˆå‹ã¯å­˜åœ¨ã—ãªã„ï¼ä»¥ä¸‹ã¯ç©ºã®structã‚’valueã¨ã—ã¦æŒã¤mapå‹ã‚’å®šç¾©ã™ã‚‹ç°¡æ˜“ãªå®Ÿè£…ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
type Set map[interface{}]struct{} // Setå‹ã®å®šç¾©

func NewSet() *Set { // æ–°ã—ã„é›†åˆã‚’ä½œæˆ
	return &Set{}
}

func (s Set) Add(key interface{}) { // é›†åˆã«å€¤ã‚’è¿½åŠ 
	s[key] = struct{}{}
}

func (s Set) Delete(key interface{}) { // é›†åˆã‹ã‚‰å€¤ã‚’å‰Šé™¤
	_, ok := s[key] // å€¤ã®å­˜åœ¨åˆ¤å®š
	if ok {
		delete(s, key)
	}
}

func main() {
    s := NewSet() // é›†åˆã‚’ä½œæˆ
    s.Add("a") // å€¤ã®è¿½åŠ 
    s.Add("b") // å€¤ã®è¿½åŠ 
    s.Add("c") // å€¤ã®è¿½åŠ 
    fmt.Println("Before:", len(*s), s) // mapå‹ã®ãŸã‚len()é–¢æ•°ãŒåˆ©ç”¨å¯
    s.Delete("b") // å€¤ã®å‰Šé™¤
    fmt.Println("After :")
    for k, _ := range s { // å€¤ã‚’å–ã‚Šå‡ºã™ã¨ãã¯mapã¨åŒã˜ã‚ˆã†ã«
        fmt.Println(k.(string))
    }
}
~~~

## find
æ¦‚è¦
æŒ‡å®šã—ãŸå€¤ãŒé…åˆ—å†…ã«å­˜åœ¨ã™ã‚‹ã‹åˆ¤åˆ¥ã™ã‚‹ï¼
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
package main

import (
    "fmt"

    "golang.org/x/exp/slices"
)

func main() {
    items := []string{"foo", "bar", "baz"}
    result := slices.Contains(items, "foo")
    fmt.Println(result) // true
    result = slices.Contains(items, "abc")
    fmt.Println(result) // false
}
~~~

## next_permutation
æ¦‚è¦

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
~~~go
func NextPermutation(x sort.Interface) bool {
	n := x.Len() - 1
	if n < 1 {
		return false
	}
	j := n - 1
	for ; !x.Less(j, j+1); j-- {
		if j == 0 {
			return false
		}
	}
	l := n
	for !x.Less(j, l) {
		l--
	}
	x.Swap(j, l)
	for k, l := j+1, n; k < l; {
		x.Swap(k, l)
		k++
		l--
	}
	return true
}

func main() {
	x := []int{1, 2, 10, 4}
	sorted_x := sort.IntSlice(x)
	sort.Sort(sorted_x)
	for {
		fmt.Println(x)
		if !NextPermutation(sorted_x) {
			break
		}
	}
}
~~~
